import { createSignal, onMount, onCleanup } from 'solid-js';
import { isServer } from 'solid-js/web';
import { noop } from '@solid-primitives/utils';

// src/index.ts

// src/helpers.ts
function createInputComponent({ multiple = false, accept = "" }) {
  const element = document.createElement("input");
  element.type = "file";
  element.accept = accept;
  element.multiple = multiple;
  return element;
}
function transformFiles(files) {
  const parsedFiles = [];
  if (!files)
    return parsedFiles;
  for (const index in files) {
    const fileIndex = +index;
    if (isNaN(+fileIndex)) {
      continue;
    }
    const file = files[fileIndex];
    if (!file) {
      continue;
    }
    const parsedFile = {
      source: URL.createObjectURL(file),
      name: file.name,
      size: file.size,
      file
    };
    parsedFiles.push(parsedFile);
  }
  return parsedFiles;
}
function createFileUploader(options) {
  if (isServer) {
    return {
      files: () => [],
      selectFiles: noop,
      removeFile: noop,
      clearFiles: noop
    };
  }
  const [files, setFiles] = createSignal([]);
  let userCallback = () => {
  };
  const onChange = async (event) => {
    event.preventDefault();
    event.stopPropagation();
    const target = event.currentTarget;
    let parsedFiles = [];
    if (target.files) {
      parsedFiles = transformFiles(target.files);
    }
    target.removeEventListener("change", onChange);
    target.remove();
    setFiles(parsedFiles);
    try {
      await userCallback(parsedFiles);
    } catch (error) {
      console.error(error);
    }
    return;
  };
  const selectFiles = (callback) => {
    if (callback) {
      userCallback = callback;
    }
    const inputElement = createInputComponent(options || {});
    inputElement.addEventListener("change", onChange);
    inputElement.click();
  };
  const removeFile = (fileName) => {
    setFiles((prev) => prev.filter((f) => f.name !== fileName));
  };
  const clearFiles = () => {
    setFiles([]);
  };
  return {
    files,
    selectFiles,
    removeFile,
    clearFiles
  };
}
function createDropzone(options) {
  if (isServer) {
    return {
      setRef: noop,
      files: () => [],
      isDragging: () => false,
      removeFile: noop,
      clearFiles: noop
    };
  }
  const [files, setFiles] = createSignal([]);
  const [isDragging, setIsDragging] = createSignal(false);
  let ref = void 0;
  const setRef = (r) => {
    ref = r;
  };
  const onDragStart = (event) => {
    setIsDragging(true);
    Promise.resolve(options?.onDragStart?.(transformFiles(event.dataTransfer?.files || null)));
  };
  const onDragEnd = (event) => {
    setIsDragging(false);
    Promise.resolve(options?.onDragEnd?.(transformFiles(event.dataTransfer?.files || null)));
  };
  const onDragEnter = (event) => {
    Promise.resolve(options?.onDragEnter?.(transformFiles(event.dataTransfer?.files || null)));
  };
  const onDragLeave = (event) => {
    Promise.resolve(options?.onDragLeave?.(transformFiles(event.dataTransfer?.files || null)));
  };
  const onDragOver = (event) => {
    event.preventDefault();
    Promise.resolve(options?.onDragOver?.(transformFiles(event.dataTransfer?.files || null)));
  };
  const onDrag = (event) => {
    Promise.resolve(options?.onDrag?.(transformFiles(event.dataTransfer?.files || null)));
  };
  const onDrop = (event) => {
    event.preventDefault();
    const parsedFiles = transformFiles(event.dataTransfer?.files || null);
    setFiles(parsedFiles);
    Promise.resolve(options?.onDrop?.(parsedFiles));
  };
  onMount(() => {
    if (!ref)
      return;
    ref.addEventListener("dragstart", onDragStart);
    ref.addEventListener("dragenter", onDragEnter);
    ref.addEventListener("dragend", onDragEnd);
    ref.addEventListener("dragleave", onDragLeave);
    ref.addEventListener("dragover", onDragOver);
    ref.addEventListener("drag", onDrag);
    ref.addEventListener("drop", onDrop);
    onCleanup(() => {
      ref?.removeEventListener("dragstart", onDragStart);
      ref?.removeEventListener("dragenter", onDragEnter);
      ref?.removeEventListener("dragend", onDragEnd);
      ref?.removeEventListener("dragleave", onDragLeave);
      ref?.removeEventListener("dragover", onDragOver);
      ref?.removeEventListener("drag", onDrag);
      ref?.removeEventListener("drop", onDrop);
    });
  });
  const removeFile = (fileName) => {
    setFiles((prev) => prev.filter((f) => f.name !== fileName));
  };
  const clearFiles = () => {
    setFiles([]);
  };
  return {
    setRef,
    files,
    isDragging,
    removeFile,
    clearFiles
  };
}

// src/index.ts
var fileUploader = (element, options) => {
  if (isServer) {
    return;
  }
  const { userCallback, setFiles } = options();
  onMount(() => {
    const onChange = async (event) => {
      const parsedFiles = transformFiles(event.currentTarget.files);
      setFiles(parsedFiles);
      try {
        await userCallback(parsedFiles);
      } catch (error) {
        console.error(error);
      }
      return;
    };
    onCleanup(() => element.removeEventListener("change", onChange));
    element.addEventListener("change", onChange);
  });
};

export { createDropzone, createFileUploader, fileUploader };
